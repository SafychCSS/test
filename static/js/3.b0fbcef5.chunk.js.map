{"version":3,"sources":["components/Profile/Profile.module.css","components/Profile/ProfileInfo/ProfileInfo.module.css","components/Profile/ProfileInfo/ProfileStatusWithHooks.js","components/Profile/ProfileInfo/ProfileStatus.js","components/Profile/ProfileInfo/ProfileInfo.js","components/Profile/MyPosts/Post/Post.js","components/Profile/MyPosts/MyPosts.js","components/Profile/MyPosts/MyPostsContainer.js","components/Profile/Profile.js","components/Profile/ProfileContainer.js"],"names":["module","exports","ProfileStatusWithHooks","React","Component","props","useState","editMode","setEditMode","status","setStatus","useEffect","onDoubleClick","onChange","e","currentTarget","value","autoFocus","onBlur","updateUserStatus","type","ProfileInfo","profile","className","pi","fullname","fullName","img","src","photos","small","user","item","aboutMe","lookingForAJob","lookingForAJobDescription","Object","entries","contacts","map","i","key","val","href","Preloader","Post","message","likeCount","MyPosts","memo","console","log","postsElem","posts","id","NewPostReduxForm","onSubmit","addPost","newPostMessage","maxLength5","maxLengthCreator","reduxForm","form","handleSubmit","Field","validate","required","component","Textarea","name","placeholder","MyPostsContainer","connect","state","profilePage","postData","newPostText","dispatch","addPostActionCreator","updatePostActionCreator","text","Profile","p","main","ProfileContainer","userId","this","match","params","authorizedUserId","history","push","getUserProfile","getUserStatus","compose","auth","isAuth","withRouter"],"mappings":"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","file":"static/js/3.b0fbcef5.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"main\":\"Profile_main__i_Ywg\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"img\":\"ProfileInfo_img__3mL1Z\",\"user\":\"ProfileInfo_user__5KL9Y\",\"item\":\"ProfileInfo_item__3HQDF\",\"profile\":\"ProfileInfo_profile__2esos\"};","import React, {useEffect, useState} from 'react';\r\n\r\n/*\r\n благодаря хукам можно переписать на функциональную компоненту, классовой она была только потому что\r\n нам нужен локальный стэйт и методы жизненного цикла\r\n реакт видит вызов хуки и запоминает\r\n хуки начинаются с use\r\n */\r\nconst ProfileStatusWithHooks = (props) => {\r\n    /*\r\n    useState - возвращает массив из двух элементов, первый это значение которое хранится в стэйте - мы пепредали по умолчанию false\r\n    то есть\r\n    let stateWithSetState = useState(false);\r\n    let editMode = stateWithSetState[0]; - это первый элмемент массива который false\r\n    let SetEditMode = stateWithSetState[1]; - второй элемент массива функция которая будет изменять значение\r\n    первого элемента массива stateWithSetState[0] - editMode\r\n\r\n    к примеру мы передаем useState(1); - это значение запоминается в реакте, также там висит функция которая меняет эту 1\r\n    когда она становится 2 реакт делает перерисовку и запоминает 2, а у на при первом вызове указано useState(1)\r\n    и эта 1 уже игнорируется, так как реакт помнит что он уже перерисовал с 2 и будет помнить 2\r\n    */\r\n\r\n    /* перепишем через деструктуризацию\r\n    let stateWithSetState = useState(false);\r\n    let editMode = stateWithSetState[0];\r\n    let SetEditMode = stateWithSetState[1];\r\n    // ваще так не пишут умные люди, используют деструктуризацию [a, b] = [10, 20] получается a = 10, b = 20\r\n\r\n\r\n    также у нас в классовой компоненте было два свойтсва в локальном стэйте, в хуках можно передать объектом\r\n    useState({editMode: false, status: props.status}), но так не делают (вроде как, со слов Димыча), в классовой\r\n    компоненте оба свойства менялись у нас отдельно друг от друга\r\n    концепция state в хуках говорит дробите стэйт на части, типа пусть будет два локальных стэйта (или скока там надо)\r\n    типа так:\r\n\r\n    let [editMode, setEditMode] = useState(false);\r\n    let [status, setStatus] = useState(props.status);\r\n\r\n\r\n    также есть проблема отрисовки статуса в input value={status}, так как он ингода не успевает прийти, а рендер уже произошел\r\n    в классовой компоненте решали через жизненный цикл componentDidUpdate, в хуках такого нет, но есть чото подобное о чем я пока не в курсе) типа useEffect наверно\r\n     */\r\n    let [editMode, setEditMode] = useState(false);\r\n    let [status, setStatus] = useState(props.status);\r\n    // useEffect - это такой хук, который говорит закиньте в меня функцию которую я выполню после отрисовки (рендера)\r\n    /*\r\n    добавляем useEffect\r\n    useEffect( () => {\r\n        setStatus(props.status);\r\n    } );\r\n    и если оставить так, то в инпуте ничего не будет печататься, точнее видимо это не заметно, мы вводим букву и попадаем в\r\n    onStatusChange и сетаем введенную букву, происходит отрисовка и выполняется useEffect который снова ставит статус который пришел\r\n    изначально и получается замкнутый круг,  поэтому нужно добавить вторым параметром массив зависимостей, только пустой как бы нельзя задавать, но так делают некоторые\r\n    в итоге мы добавляем в useEffect зависимость [props.status] и говорим если props.status при отрисовке будет не таким каким был раньше\r\n    запусти наш эффект - useEffect\r\n\r\n    !!!!!!хуки нельзя использовать в условиях, циклах и еще где-то\r\n     */\r\n    useEffect( () => {\r\n        setStatus(props.status);\r\n    }, [props.status]);\r\n\r\n    const activateEditMode = () => {\r\n        setEditMode(true); // - поменяли editMode в true через функцию setEditMode\r\n    };\r\n    const deactivateEditMode = () => {\r\n        setEditMode(false);\r\n        props.updateUserStatus(status);\r\n    };\r\n    const onStatusChange = (e) => {\r\n        setStatus(e.currentTarget.value);\r\n    };\r\n    return (\r\n        <div>\r\n            {!editMode &&\r\n            <span onDoubleClick={activateEditMode}>{props.status || '-----'}</span>\r\n            }\r\n            {editMode &&\r\n            <input onChange={onStatusChange} autoFocus={true}\r\n                   onBlur={deactivateEditMode} value={status} type=\"text\"/>\r\n            }\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default ProfileStatusWithHooks;","import React from 'react';\r\n\r\n/*\r\n благодаря хукам можно переписать на функциональную компоненту, классовой она была только потому что\r\n нам нужен локальный стэйт и методы жизненного цикла\r\n реакт видит вызов хуки и запоминает\r\n перепишем в ProfileStatusWithHooks\r\n */\r\nclass ProfileStatus extends React.Component {\r\n\r\n    state = {\r\n        editMode: false,\r\n        status: this.props.status\r\n    };\r\n/*\r\n    activateEditMode = () => {\r\n        // this.state.editMode так нельзя менять данные для этого есть метод setState, при этом exampleField: 'axaxax' останется\r\n        // не тронутым\r\n        console.log(this.state);\r\n        this.setState({\r\n            editMode: true\r\n        })\r\n    };\r\n*/\r\n    // можно не стрелочный метод а по старинке) тогда надо будет привязывать контекст либо в конструкторе либо в при передаче колбека\r\n\r\n /* заменим все стрелочными функциями и избавимся от bind\r\n  activateEditMode() {\r\n        this.setState({\r\n            editMode: true\r\n        })\r\n    }\r\n\r\n    deactivateEditMode(e) {\r\n        this.setState({\r\n            editMode: false\r\n        })\r\n    }\r\n\r\n\r\n    render() {\r\n        return (\r\n            <div>\r\n                {!this.state.editMode &&\r\n                    <span onDoubleClick={this.activateEditMode.bind(this)}>{this.props.status}</span>\r\n                }\r\n                {this.state.editMode &&\r\n                    <input onChange={() => {}} autoFocus={true} onBlur={this.deactivateEditMode.bind(this)} type=\"text\" defaultValue={this.props.status}/>\r\n                }\r\n            </div>\r\n        );\r\n    }*/\r\n\r\n    activateEditMode = () => {\r\n        this.setState({\r\n            editMode: true\r\n        });\r\n    };\r\n\r\n    deactivateEditMode = (e) => {\r\n        this.setState({\r\n            editMode: false\r\n        });\r\n        this.props.updateUserStatus(this.state.status);\r\n    };\r\n\r\n    onStatusChange = (e) => {\r\n        this.setState({\r\n            status: e.target.value\r\n        });\r\n    };\r\n\r\n    /*\r\n    напоминаем - жизненный цикл - есть классовая компонента, на ее базе создался объект и реакт с ним взаимодействует\r\n    вызывает рендер и после уведомляет нашу компоненту componentDidMount о том что он отрисовал\r\n    компоненту (вставил в дом append jsx - грубо говоря), в след раз когда компонента меняется (props поменялся)\r\n    и реакт говорит давай мне новый jsx у тебя ж там что-то поменялось и уже не append новый jsx а update и\r\n    уведомляет компоненту componentDidUpdate - компонента ты обновилась (state или props) - а мы уже можем с этим взаимодействовать\r\n\r\n    у нас тут есть локальный стэйт и глобальный, по двойному клику на статус обновляется локальный state\r\n    editMode: false -> editMode: true у нас произойдет рендер снова и мы попадем в componentDidUpdate\r\n    */\r\n\r\n    componentDidUpdate(prevProps, prevState) {\r\n        // сюда приходят prevProps, prevState, соответственно мы можем понять что изменилось\r\n        // сначала что-то меняется, потом идет рендер, потом мы попадаем сюда\r\n        // если тут менять setState то после обновления мы опять будем делать рендер, попадать сюда\r\n        // менять setState делать рендер и по кругу, короче скрипт ляжет, поэтому всегда в данном методе setState\r\n        // должен лежать внутри какого-то условия, не любого конечно))\r\n        if (prevProps.status !== this.props.status) {\r\n            this.setState({\r\n                status: this.props.status\r\n            })\r\n        }\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div>\r\n                {!this.state.editMode &&\r\n                    /*\r\n                    было <span onDoubleClick={this.activateEditMode}>{this.props.status || '------'}</span>\r\n                    статус был из пропсов, но я получал постоянно ошибку при попытке обновления статуса и так не понял почему\r\n                    вероятнопри последующей попытке получить статус из пропсов хз куда проваливался так как асинхронщина,\r\n                    но это конечно не точно, ошибка //Objects are not valid as a React child\r\n                    типа как-будто мне приходил объект и я его засовывал в jsx???!!?!?!?!\r\n\r\n                    вот трабла в ProfileContainer мы делаем два запроса\r\n                    this.props.getUserProfile(userId);\r\n                    this.props.getUserStatus(userId);\r\n                    , а у нас в ProfileInfo есть код на проверку пришел ли статус, и тока тогда профайл показывается\r\n                    if (!props.profile) {\r\n                        return <Preloader/>\r\n                    }\r\n                    так вот если статус успел сделать запрос (точнее прийти первее) то показывается все норм, а если профайл сначала\r\n                    пришел то он отображается и на статус уже насрано\r\n                    полагаю можно сделать проверку на об пришедших значения, но в таком случае, так как статус нам особо не важен,\r\n                    может запрос вообще не пройти, тогда будет фигово, из-за статуса мы не увидим вообще ничего или я хз\r\n\r\n                    раз axios нам промисы возвращает можно дождаться всех ответов, полагаю через promise all - но это вроде как\r\n                    та же проблема, или нет пока хз\r\n\r\n                    о вообще статус есть в самом профиле и можно оттуда его брать, так будет гуд\r\n                    но поскоку я тока учусь идем через методы жизненного цикла componentDidUpdate\r\n                    */\r\n                    <span onDoubleClick={this.activateEditMode}>{this.props.status || '-----'}</span>\r\n                }\r\n                {this.state.editMode &&\r\n                    <input onChange={this.onStatusChange} autoFocus={true} onBlur={this.deactivateEditMode} type=\"text\" value={this.state.status || ''}/>\r\n                }\r\n            </div>\r\n        );\r\n    }\r\n}\r\n\r\nexport default ProfileStatus;","import React from 'react';\r\nimport pi from './ProfileInfo.module.css';\r\nimport Preloader from '../../../common/Preloader/Preloader';\r\nimport ProfileStatus from './ProfileStatus';\r\nimport {userStatus} from '../../../api/api';\r\nimport ProfileStatusWithHooks from './ProfileStatusWithHooks';\r\n\r\n/*\r\n    задача создать классовую компоненту которая будет хранить локальный state и отображать статус пользователя\r\n    или поле для его изменения, изначально текст, клик по тексту заменят текст на инпут, клик вне инпута сохраняет введенный\r\n    статус и возвращает текс\r\n\r\n    локальный стэйт используют если он нужен только в одной кокретной компоненте и от него не зависит ничего вообще в глобальном плане\r\n    в нашем примере это статус пользователя\r\n\r\n    если в классовой компоненте создать метод обычным способом method() то при его вызове где-то в копмоненте this.method\r\n    потеряется контекст вызова, поэтому надо либо привязывать через bind в самом вызове или в конструкторе или\r\n    создавать метод с помощью стрелочных функций\r\n\r\n    есть еще косяк в режиме дебага в стрелочной функции this показывает undefined (иногда?)\r\n*/\r\n\r\nconst ProfileInfo = (props) => {\r\n    //у нас изначально рисуется компонента, но данных еще нет, поэтмоу в картинке мы получаем ошибку и скрипт падает\r\n    // поэтому проверяем пришли ли данные, если нет пока выводим крутилку, то есть по умолчанию реакт сразу рендерит компоненту\r\n    // без данных, мы говорим !props.profile если данных нет, верни компоненту прелодер, потом приходят данные и мы рендерим уже нашу компоненту\r\n    if (!props.profile) {\r\n        return <Preloader/>\r\n    }\r\n    return (\r\n        <div className={pi.profile}>\r\n            <h3 className={pi.fullname}>{props.profile.fullName}</h3>\r\n            <ProfileStatusWithHooks status={props.status} updateUserStatus={props.updateUserStatus} />\r\n            <div className={pi.img}><img src={props.profile.photos.small} /></div>\r\n            <div className={pi.user}>\r\n                <div className={pi.item}>{props.profile.aboutMe}</div>\r\n                <p>В поисках работы: {props.profile.lookingForAJob ? <span>Да</span> : <span>Нет</span>}</p>\r\n                {props.profile.lookingForAJobDescription ? <p>Какую работу хочу: {props.profile.lookingForAJobDescription}</p> : ''}\r\n                <div>Я есть в таких соц сетях (ссылку не дам):\r\n                    {Object.entries(props.profile.contacts).map(([key, val], i) => (\r\n                        <div key={i} className=\"card-panel\">\r\n                            {key}:<a href={\"https://\" + val}>{val}</a>\r\n                        </div>\r\n                    ))}\r\n                </div>\r\n            </div>\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default ProfileInfo;","import React from 'react';\r\nimport p from './Post.module.css';\r\n\r\nconst Post = (props) => {\r\n    return (\r\n        <div className=\"post\">\r\n            <p className=\"text\">{props.message} {props.likeCount}</p>\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default Post;","import React from 'react';\r\nimport Post from './Post/Post';\r\nimport {Field, reduxForm} from 'redux-form';\r\nimport {maxLengthCreator, required} from '../../../utils/validators/validators';\r\nimport {Textarea} from '../../../common/FormsControls/FormsControls';\r\n\r\n// в классовой компоненте чтобы по 10 раз не рендерилось нужно вызвать shouldComponentUpdate и проверить изменились ли пропсы или стэйт\r\n// если ничего не менялось то и рендерить не будем\r\n// хотя что-то мне подсказывает что сейчас и так все рендерится нормально\r\n// тут shouldComponentUpdate как бы реакт спрашивает нужно ли тебя перерисовывать\r\n/*shouldComponentUpdate(nextProps, nextState) {\r\n    return nextProps != this.props || nextState != this.state;\r\n}*/\r\n\r\n/*\r\nчтобы не писать shouldComponentUpdate можно наследовать класс от PureComponent\r\nclass MyPosts extends React.PureComponent\r\nclass MyPosts extends PureComponent тоже что и выше\r\nclass MyPosts extends React.Component\r\nclass MyPosts extends Component тоже что и выше\r\nвнутри PureComponent логика с shouldComponentUpdate уже сделана за нас\r\n\r\n\r\nв функциональной компоненте можно обернуть функцию в React.memo по сути тоже что и shouldComponentUpdate в классовой\r\n */\r\n\r\nconst MyPosts = React.memo((props) => {\r\n    console.log('asd');\r\n    let postsElem = props.posts.map(item => <Post\r\n        message={item.message}\r\n        likeCount={item.likeCount}\r\n        key={item.id} />);\r\n\r\n    //let newPostElem = React.createRef(); //ссылка на элемент для дальнейшего взаимодействия - добавляем к эелемнту через ref\r\n\r\n    const addNewPost = (value) => {\r\n        props.addPost(value.newPostMessage);\r\n    };\r\n\r\n    /*let onPostChange = () => {\r\n        props.updatePostActionCreator(newPostElem.current.value);// можно сразу засунуть объект\r\n    };*/\r\n\r\n    return (\r\n        <div className=\"posts\">\r\n            <h3>My posts</h3>\r\n            <NewPostReduxForm onSubmit={addNewPost} />\r\n            {postsElem}\r\n        </div>\r\n    );\r\n});\r\n\r\n// все что ниже было бы неплохо перенести в отдельную компоненту\r\n\r\n//validate={[required, maxLength]} внутри validate нельзя вызывать maxLengthCreator(5), нужно передать как параметр\r\nconst maxLength5 = maxLengthCreator(5);\r\n\r\nconst NewPostFrom = (props) => {\r\n    return (\r\n        <form onSubmit={props.handleSubmit} className=\"\">\r\n            <div>\r\n                {/*\r\n                чтобы создать какой-то инпут, текстарею или другой элемент, чтобы добавить в него каких-то особенных\r\n                стилей нужно в Field передавать в component компонент, а не строку с названием элемента который он должен создать\r\n                сам компонент мы создадим который нам будет нужен\r\n                <Field validate={[required, maxLength5]} component={\"textarea\"} className=\"textarea\" name=\"newPostMessage\" id=\"\" cols=\"30\" rows=\"5\" />\r\n                все данные из Field попадут в компоненту Textarea через пропсы, все, то если мы добавим к Field placeholder\r\n                то он придет через пропсы в Textarea\r\n                 */}\r\n                <Field validate={[required, maxLength5]} component={Textarea} name=\"newPostMessage\" placeholder=\"Add new post\" />\r\n            </div>\r\n            <div>\r\n                <button>Добавить</button>\r\n            </div>\r\n        </form>\r\n    )\r\n};\r\n\r\nconst NewPostReduxForm = reduxForm({\r\n    // необходимо дать уникальное имя\r\n    form: 'postAddMessage'\r\n})(NewPostFrom);\r\n\r\n\r\nexport default MyPosts;","import React from 'react';\r\nimport {addPostActionCreator, updatePostActionCreator} from '../../../redux/profile-reducer';\r\nimport MyPosts from './MyPosts';\r\nimport {connect} from 'react-redux';\r\n\r\nlet mapStateToProps = (state) => {\r\n    return {\r\n        posts: state.profilePage.postData,\r\n        newPostText: state.profilePage.newPostText\r\n    }\r\n};\r\n\r\nlet mapDispatchToProps = (dispatch) => {\r\n    return {\r\n        addPost: (newPostMessage) => {\r\n            dispatch(addPostActionCreator(newPostMessage));\r\n        },\r\n        updatePostActionCreator: (text) => {\r\n            dispatch(updatePostActionCreator(text));\r\n        }\r\n    }\r\n};\r\nconst MyPostsContainer = connect(mapStateToProps, mapDispatchToProps)(MyPosts);\r\n\r\n\r\n/*const MyPostsContainer = () => {\r\n    return (\r\n        <StoreContext.Consumer>\r\n            {(store) => {\r\n                let state = store.getState();\r\n\r\n                const addNewPost = () => {\r\n                    store.dispatch(addPostActionCreator());\r\n                };\r\n\r\n                let onPostChange = (text) => {\r\n                    store.dispatch(updatePostActionCreator(text));// можно сразу засунуть объект\r\n                };\r\n                return <MyPosts\r\n                    updatePostActionCreator={onPostChange}\r\n                    addPost={addNewPost}\r\n                    posts={state.profilePage.postData}\r\n                    newPostText={state.profilePage.newPostText}/>\r\n            }\r\n        }\r\n        </StoreContext.Consumer>\r\n    );\r\n};*/\r\n\r\nexport default MyPostsContainer;","import React from 'react';\r\nimport p from './Profile.module.css';\r\nimport ProfileInfo from './ProfileInfo/ProfileInfo';\r\nimport MyPostsContainer from './MyPosts/MyPostsContainer';\r\n\r\n// mapStateToProps и mapDispatchToProps скрывают от нас многие детали, мы диспатчим все через store, state берем у store, store хранилище state, когда мы что-либо диспатчим store берет action и прокидывает по всем редьюсорам и state преобразовывается и так по кругу, flux круговорот\r\n\r\nconst Profile = (props) => {\r\n    return (\r\n        <main className={p.main}>\r\n            <ProfileInfo profile={props.profile} status={props.status} updateUserStatus={props.updateUserStatus}/>\r\n            <MyPostsContainer />\r\n        </main>\r\n    );\r\n};\r\n\r\nexport default Profile;","import React from 'react';\r\nimport Profile from './Profile';\r\nimport {connect} from 'react-redux';\r\nimport {getUserProfile, getUserStatus, updateUserStatus} from '../../redux/profile-reducer';\r\nimport {withRouter} from 'react-router-dom';\r\nimport {withAuthRedirect} from '../../hoc/withAuthRedirect';\r\nimport {compose} from 'redux';\r\n\r\n// еще раз — конейнерная компонента, она же типа грязная, занимается \"доставкой\" данных для презентационной компоненты\r\n//{...this.props} - так мы прокидываем все props которые пришли сюда дальше в презентационную компоненту\r\n// если например передать props={this.props} и a={12} то в през комп придет объект с свойствами а: 12, props: {объект пропсов}\r\nclass ProfileContainer extends React.Component {\r\n    //componentDidMount(компонента уже вмонтирована) - метод жизненного цикла, есть у объекта, который создан с помощью данного класса, отвечает за компоненту\r\n    componentDidMount() {\r\n        /*\r\n         this.props.authorizedUserId - проверим если залогинены то показываем нашу страницу, если нет, то у нас по умолчанию\r\n         редирект на логин стоит, но можно редиректить просто на список пользователей или хз куда\r\n\r\n         кстати есть косяк, если убрать редирект с профиля для неавторизавонных, то после авторизации и попадания на страницу /profile\r\n         то есть своего профиля у нас данные профиля не будут получены и по сути страница не загружается, но если сходить на\r\n          другую страницу и потом вернуться в /profile то уже норм, происходит это из-за того что при обновлении запрос на авторизацию еще не ушел, а мы уже на странице, а при редиректе не авторизационного пользователя, нас редиректит на логин, запрос успевает прийти и мы попадаем назад как норм пользователь - авторизованный, в итоге это можно решить, например, ожиданием, показывать\r\n          крутилку пока загружается все, а не кидать на логин, потом обратно и тд - косяк правим в App.js\r\n         */\r\n        let userId = this.props.match.params.userId;\r\n        if (!userId) {\r\n            userId = this.props.authorizedUserId;\r\n            /*\r\n            вариант редиректа такой себе, по хорошему переход должен быть инициирован из state\r\n             */\r\n            if (!userId) {\r\n                this.props.history.push('/login');\r\n            }\r\n        }\r\n        this.props.getUserProfile(userId);\r\n        this.props.getUserStatus(userId);\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <Profile {...this.props} profile={this.props.profile}\r\n                     status={this.props.status} updateUserStatus={this.props.updateUserStatus}/>\r\n        )\r\n    }\r\n};\r\n\r\n// если функция возвращает объект ставим круглые скобки, затем фигурные\r\nlet mapStateToProps = (state) => ({\r\n    profile: state.profilePage.profile,\r\n    status: state.profilePage.status,\r\n    authorizedUserId: state.auth.userId,\r\n    isAuth: state.auth.isAuth,\r\n});\r\n//WithUrlDataContainerComponent - еще одна контейнерная компонента для чтобы получить данные по урл, withRouter - возвращает компоненту,\r\n// которая закинет данные из урла, и дальше уже ее закидываем в connect - после в props добавятся history, location, match и тд\r\n// в match - будут совпадения с нашим router, те адреса что в App.js обернуты (path='/profile'), в match есть объект params, в котором\r\n// должна быть как раз часть урла, которая нужна (например http://localhost:3000/profile/8026) - 8026, но там сейчас приходит пустой\r\n// объект(так же там есть параметр isExact: false, который говорит что совпала только часть урла /profile)\r\n// чтобы params заполнялся реактом поменяем path в App.js c path='/profile' на path='/profile/:userId' и теперь\r\n// мы можем получить этот userId через пропсы (this.props.match.params.userId) и передать в componentDidMount в качестве параметра для урл\r\n// если добавить вопр знак в конец path='/profile/:userId?' то мы говорим, что параметр userId не обязательный, таким образом\r\n// /profile тоже будет открываться, но для него нужно задать свои парамтры отображения (что нам на этой стр рендерить)\r\n\r\n\r\n// HOC - контейнерная компонента не обзяательно классовая или функциональная или презенационная, она просто над другой компонентой\r\n// в этом случае AuthRedirectComponent контейнерная над ProfileContainer\r\n// и это вообше не HOC, HOC у нас тут withAuthRedirect, а это просто функция, щас перепишем как должно быть\r\n/*\r\nтеперь мы не дублируем код\r\nconst AuthRedirectComponent = (props) => {\r\n    if (!this.props.isAuth)\r\n        return <Redirect to='/login' />;\r\n\r\n    return <ProfileContainer {...props} />\r\n};\r\n*/\r\n\r\n/*\r\n чтобы isAuth: state.auth.isAuth не передавать везде (не прокидывать в каждой компоненте в state), сделаем два connect,\r\n в первый передадим mapStateToProps с isAuth: state.auth.isAuth, а во второй как есть, это ад, но видимо для понимания надо\r\n но чот я не особо понимаю этого бреда, еще и через let AuthRedirectComponent делаем и перезаписываем ее\r\n mapStateToPropsForRedirect и это мы перенесем в сам hoc withAuthRedirect\r\n*/\r\n\r\n// закинули в compose let AuthRedirectComponent = withAuthRedirect(ProfileContainer);\r\n\r\n/* перенесли withAuthRedirect и сделали connect там и передали isAuth: state.auth.isAuth\r\nlet mapStateToPropsForRedirect = (state) => ({\r\n    isAuth: state.auth.isAuth\r\n});\r\nAuthRedirectComponent = connect(mapStateToPropsForRedirect)(AuthRedirectComponent);*/\r\n\r\n// и теперь тут не ProfileContainer будем коннектить а AuthRedirectComponent\r\n// let WithUrlDataContainerComponent = withRouter(ProfileContainer);\r\n\r\n// закинули в compose let WithUrlDataContainerComponent = withRouter(AuthRedirectComponent);\r\n\r\n/*\r\n можно так, а можно через compose, о нем узнаем дальше let WithUrlDataContainerComponent = withRouter(ProfileContainer);\r\n export default withAuthRedirect(connect(mapStateToProps, {getUserProfile})(WithUrlDataContainerComponent));\r\n*/\r\n/*\r\n compose()() второй раз вызвыается функция которую вернул compose\r\n compose(withAuthRedirect)(ProfileContainer); - начинаем с конца, сначала берем ProfileContainer и он попадает в withAuthRedirect\r\n compose автоматически возьмет ProfileContainer и закинет ее в вызов функции withAuthRedirect\r\n\r\n затем возьмет результат выполнения withAuthRedirect и перекинет этот результат в следующую функцию withRouter\r\n\r\n затем этот результат закинет в след функцию, какя это функция?\r\n та что возвращает нам connect, а connect возвращает hoc и мы его уже закидываем в компоненту\r\n\r\n короче вот какой смысл, чтобы не писать по 100 раз вызов в вызове compose, сейчас конкретно про наш пример, берет\r\n ProfileContainer, закидывает его (ее - функцию, компоненту) в вызов hoc withAuthRedirect, получает результат и этот результат\r\n закидывает в withRouter, и уже результат withRouter закидывает в connect\r\n\r\n еще раз\r\n compose - мы как бы говорим ему, возьми ProfileContainer и закинь в функцию withAuthRedirect, получи результат и этот результат\r\n закинь в withRouter, получи результат и его закинь в connect(mapStateToProps, mapDispatchToProps)\r\n\r\n по итогу у нас было\r\n\r\n let AuthRedirectComponent = withAuthRedirect(ProfileContainer);\r\n\r\n let WithUrlDataContainerComponent = withRouter(AuthRedirectComponent);\r\n\r\nconst DialogsContainer = connect(mapStateToProps, mapDispatchToProps)(AuthRedirectComponent);\r\n\r\nexport default connect(mapStateToProps, {getUserProfile})(WithUrlDataContainerComponent);\r\n\r\n\r\nтеперь мы можем сделать так\r\nexport default compose(\r\n    connect(mapStateToProps, {getUserProfile}),\r\n    withRouter,\r\n    withAuthRedirect\r\n)(ProfileContainer);\r\n\r\n*/\r\n\r\n/*\r\n теперь если мы хотим убрать редирект для не залогиненых просто нужно убрать withAuthRedirect из compose\r\n\r\n короче по итогу !!!!!!!!!!!!!!!!!!\r\n\r\n было у нас изначально так:\r\nexport default connect(mapStateToProps, {getUserProfile})(ProfileContainer);\r\n\r\nпотом стало так - добавили withRouter чтобы открывались страницы пользователей\r\n\r\n    let WithUrlDataContainerComponent = withRouter(ProfileContainer);\r\n    export default connect(mapStateToProps, {getUserProfile})(WithUrlDataContainerComponent);\r\n\r\nпотом стало так - добавили рекдирект для не залогиненых\r\n\r\n    let AuthRedirectComponent = withAuthRedirect(ProfileContainer);\r\n    let WithUrlDataContainerComponent = withRouter(AuthRedirectComponent);\r\n    export default connect(mapStateToProps, {getUserProfile})(WithUrlDataContainerComponent);\r\n\r\n\r\nв итоге стало как в коде ниже через compose\r\n\r\nнадо удалить обработчик чтобы не было редиректа убераем withAuthRedirect, надо что-то добавить добавляем и тд\r\n\r\n*/\r\n\r\nexport default compose(\r\n    connect(mapStateToProps, {getUserProfile, getUserStatus, updateUserStatus}),\r\n    withRouter,\r\n    //withAuthRedirect\r\n)(ProfileContainer);\r\n"],"sourceRoot":""}