{"version":3,"sources":["components/Dialogs/DialogItem/DialogItem.js","components/Dialogs/Message/Message.js","components/Dialogs/AddMessageForm/AddMessageForm.js","components/Dialogs/Dialogs.js","components/Dialogs/DialogsContainer.js"],"names":["DialogItem","props","path","id","to","className","name","Message","text","maxLength7","maxLengthCreator","AddMessageReduxForm","reduxForm","form","onSubmit","handleSubmit","Field","validate","required","component","Textarea","cols","rows","Dialogs","dialogsElem","dialogsName","map","item","key","messagesElem","dialogsList","value","addNewDialog","newMessageBody","compose","connect","state","messagesPage","messagesData","dialogsData","newDialogsText","newDialogText","dispatch","addDialogActionCreator","withAuthRedirect"],"mappings":"yKAaeA,EAVI,SAACC,GAChB,IAAIC,EAAO,YAAcD,EAAME,GAE/B,OACI,kBAAC,IAAD,CAASC,GAAIF,EAAMG,UAAU,sBACzB,8BAAOJ,EAAMK,QCEVC,EARC,SAACN,GACb,OACI,yBAAKI,UAAU,aACX,2BAAIJ,EAAMO,Q,kCCAhBC,EAAaC,YAAiB,GAevBC,EAAsBC,YAAU,CAEzCC,KAAM,oBAFyBD,EAbZ,SAACX,GACpB,OACI,0BAAMa,SAAUb,EAAMc,aAAcV,UAAU,YAC1C,6BACI,kBAACW,EAAA,EAAD,CAAOC,SAAU,CAACC,IAAUT,GAAaU,UAAWC,IAAUd,KAAK,iBAAiBH,GAAG,GAAGkB,KAAK,KAAKC,KAAK,QAE7G,6BACI,4BAAQjB,UAAU,YAAlB,+DC4BDkB,EApCC,SAACtB,GAEb,IAAIuB,EAAcvB,EAAMwB,YAAYC,KAAI,SAAAC,GAAI,OAAI,kBAAC,EAAD,CAAYrB,KAAMqB,EAAKrB,KAAMH,GAAIwB,EAAKxB,GAAIyB,IAAKD,EAAKxB,QAEhG0B,EAAe5B,EAAM6B,YAAYJ,KAAI,SAAAC,GAAI,OAAI,kBAAC,EAAD,CAASnB,KAAMmB,EAAKnB,KAAMoB,IAAKD,EAAKxB,QAmBrF,OACI,0BAAME,UAAU,eACZ,yBAAKA,UAAU,gBACVmB,GAEL,yBAAKnB,UAAU,OACVwB,EACD,kBAAClB,EAAD,CAAqBG,SAVX,SAACiB,GACnB9B,EAAM+B,aAAaD,EAAME,sB,uBC6ElBC,sBACXC,aAzEkB,SAACC,GACnB,MAAO,CACHN,YAAaM,EAAMC,aAAaC,aAChCb,YAAaW,EAAMC,aAAaE,YAChCC,eAAgBJ,EAAMC,aAAaI,kBAKlB,SAACC,GACtB,MAAO,CACHV,aAAc,SAACC,GACXS,EAASC,YAAuBV,SA8DxCW,IAFWV,CAGbX","file":"static/js/4.58b1e490.chunk.js","sourcesContent":["import React from 'react';\r\nimport {NavLink} from 'react-router-dom';\r\n\r\nconst DialogItem = (props) => {\r\n    let path = '/dialogs/' + props.id;\r\n\r\n    return (\r\n        <NavLink to={path} className=\"dialogs-list__item\">\r\n            <span>{props.name}</span>\r\n        </NavLink>\r\n    );\r\n};\r\n\r\nexport default DialogItem;","import React from 'react';\r\n\r\nconst Message = (props) => {\r\n    return (\r\n        <div className=\"msg__item\">\r\n            <p>{props.text}</p>\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default Message;","import {maxLengthCreator, required} from '../../../utils/validators/validators';\r\nimport {Field, reduxForm} from 'redux-form';\r\nimport {Textarea} from '../../../common/FormsControls/FormsControls';\r\nimport React from 'react';\r\n\r\nconst maxLength7 = maxLengthCreator(7);\r\n\r\nconst AddMessageForm = (props) => {\r\n    return (\r\n        <form onSubmit={props.handleSubmit} className=\"msg__add\">\r\n            <div>\r\n                <Field validate={[required, maxLength7]} component={Textarea} name=\"newMessageBody\" id=\"\" cols=\"30\" rows=\"10\" />\r\n            </div>\r\n            <div>\r\n                <button className=\"msg__btn\">Отправить</button>\r\n            </div>\r\n        </form>\r\n    )\r\n};\r\n\r\nexport const AddMessageReduxForm = reduxForm({\r\n    // необходимо дать уникальное имя\r\n    form: 'dialogAddMessage'\r\n})(AddMessageForm);","import React from 'react';\r\nimport './Dialogs.css';\r\nimport DialogItem from './DialogItem/DialogItem';\r\nimport Message from './Message/Message';\r\nimport {AddMessageReduxForm} from './AddMessageForm/AddMessageForm';\r\n\r\nconst Dialogs = (props) => {\r\n\r\n    let dialogsElem = props.dialogsName.map(item => <DialogItem name={item.name} id={item.id} key={item.id} />);\r\n\r\n    let messagesElem = props.dialogsList.map(item => <Message text={item.text} key={item.id} />);\r\n/*\r\n    let msgtext = React.createRef();\r\n\r\n    const addDialog = (newMessageBody) => {\r\n        props.addNewDialog(newMessageBody);\r\n    };\r\n\r\n    /!*const updateDialogText = () => {\r\n        props.updDialog(msgtext.current.value);\r\n    };*!/*/\r\n\r\n    // эту проверку мы делаем на каждой странице(почти) поэтому делаем HOC hightOrderComponent принимает компоненту возвращает компоненту\r\n    // перенесли это в DialogsContainer\r\n    /*if (!props.isAuth)\r\n        return <Redirect to='/login' />;*/\r\n    const addNewMessage = (value) => {\r\n        props.addNewDialog(value.newMessageBody);\r\n    };\r\n    return (\r\n        <main className='dialogs row'>\r\n            <div className=\"dialogs-list\">\r\n                {dialogsElem}\r\n            </div>\r\n            <div className=\"msg\">\r\n                {messagesElem}\r\n                <AddMessageReduxForm onSubmit={addNewMessage} />\r\n            </div>\r\n        </main>\r\n    );\r\n};\r\n\r\nexport default Dialogs;","import React from 'react';\r\nimport {addDialogActionCreator, updateDialogActionCreator} from '../../redux/dialog-reducer';\r\nimport Dialogs from './Dialogs';\r\nimport {connect} from 'react-redux';\r\nimport {withAuthRedirect} from '../../hoc/withAuthRedirect';\r\nimport {compose} from 'redux';\r\n\r\n/* контейнерная компонента через react-redux функцию connect (наличие двух скобок в конце ()() - значит мы вызвали функцию connect а она вернула другую функцию, которую мы также вызываем вторыми скобками), во вторые скобки (функцию) передаем презентационную компоненту которую хотим отобразить - законнектить к стору.\r\nКак работает connect - создает контейнерную компоненту, внутри рендерит презентационную компаненту и внутрь в качестве пропсов передает свойства которые сидят в двух объектах возвращаемых функциями (у нас для примера f1 and f2 которые мы передаем в connect, не вызываем, а передаем) в f1 connect передаст state (= store.getState()), не store, (с функцией connect мы забываем про ООП объект store, она возвращает просто данные которыми мы пользуемся), в f2 connect засунет dispatch с привязанным контекстом (store.dispatch.bind(store))\r\nнапример f1 возвращает объект {a: 1, b: 2} значит в презентационную компоненту попадут такие свойства <Dialogs a={1} b={2} /> и внутри этой компоненты данные свойства будут доступны через пропсы props.a, props.b и тд\r\n\r\n\r\nсмысл f1 замапить state на пропсы - превратить часть state в props\r\nсмысл f2 передать коллбеки которые будем отправлять в презентационную компаненту\r\n\r\nconnect - возвращает новую контейнерную компоненту\r\n\r\nlet f1 = (state) => {\r\n    return {\r\n        a: 1,\r\n        b: 2,\r\n    }\r\n};\r\n\r\nlet f2 = (dispatch) => {\r\n    return {\r\n        c: 3\r\n    }\r\n};\r\nconst SuperDialogsContainer = connect(f1, f2)(Dialogs);\r\n*/\r\n\r\nlet mapStateToProps = (state) => {\r\n    return {\r\n        dialogsList: state.messagesPage.messagesData,\r\n        dialogsName: state.messagesPage.dialogsData,\r\n        newDialogsText: state.messagesPage.newDialogText,\r\n        //isAuth: state.auth.isAuth - перенесли в hoc ниже\r\n    }\r\n};\r\n\r\nlet mapDispatchToProps = (dispatch) => {\r\n    return {\r\n        addNewDialog: (newMessageBody) => {\r\n            dispatch(addDialogActionCreator(newMessageBody));\r\n        },\r\n        /*updDialog: (text) => {\r\n            dispatch(updateDialogActionCreator(text));\r\n        }*/\r\n    }\r\n};\r\n\r\n// HOC - контейнерная компонента не обзяательно классовая или функциональная или презенационная, она просто над другой компонентой\r\n// в этом случае AuthRedirectComponent контейнерная над Dialogs\r\n// и это вообше не HOC, HOC у нас тут withAuthRedirect, а это просто функция, щас перепишем как должно быть\r\n/*\r\nтеперь мы не дублируем код\r\nconst AuthRedirectComponent = (props) => {\r\n    if (!this.props.isAuth)\r\n        return <Redirect to='/login' />;\r\n\r\n    return <Dialogs {...props} />\r\n};\r\n*/\r\n\r\n/*\r\n чтобы isAuth: state.auth.isAuth не передавать везде (не прокидывать в каждой компоненте в state), сделаем два connect,\r\n в первый передадим mapStateToProps с isAuth: state.auth.isAuth, а во второй как есть, это ад, но видимо для понимания надо\r\n но чот я не особо понимаю этого бреда, еще и через let AuthRedirectComponent делаем и перезаписываем ее\r\n\r\n актуальная инфа в ProfileContainer\r\n*/\r\n\r\n/*\r\n compose()() второй раз вызвыается функция которую вернул compose\r\n compose(withAuthRedirect)(Dialogs); - начинаем с конца, сначала берем Dialogs и он попадает в withAuthRedirect\r\n compose автоматически возьмет Dialogs и законет ее в вызов функции withAuthRedirect\r\n затем возьмет результат выполнения withAuthRedirect и перекинет этот результат в следующую функцию, какя это функция?\r\n та что возвращает нам connect, а connect возвращает hoc и мы его уже закидываем в компоненту\r\n\r\n короче вот какой смысл, чтобы не писать по 100 раз вызов в вызове compose, сейчас конкретно про наш пример, берет\r\n Dialogs, закидывает его (ее - функцию, компоненту) в вызов hoc withAuthRedirect, получает результат и этот результат\r\n закидывает в connect\r\n\r\n еще раз\r\n compose - мы как бы говорим ему, возьми Dialogs и закинь в функцию withAuthRedirect, получи результат и этот результат\r\n закинь в connect(mapStateToProps, mapDispatchToProps)\r\n\r\n по итогу у нас было\r\n\r\n let AuthRedirectComponent = withAuthRedirect(Dialogs);\r\n\r\nconst DialogsContainer = connect(mapStateToProps, mapDispatchToProps)(AuthRedirectComponent);\r\n\r\nexport default DialogsContainer;\r\n\r\nтеперь мы можем сделать так\r\nexport default compose(\r\n    connect(mapStateToProps, mapDispatchToProps),\r\n    withAuthRedirect\r\n)(Dialogs);\r\n\r\n*/\r\n\r\nexport default compose(\r\n    connect(mapStateToProps, mapDispatchToProps),\r\n    withAuthRedirect\r\n)(Dialogs);\r\n\r\n\r\n// КОНТЕЙНЕРНАЯ КОМПОНЕНТА для передачи презентационной state и callback функцией созданная нами\r\n/*const DialogsContainer = () => {\r\n    return (\r\n        <StoreContext.Consumer>\r\n            {(store) => {\r\n                let state = store.getState();\r\n\r\n                const addDialog = () => {\r\n                    store.dispatch(addDialogActionCreator());\r\n                };\r\n\r\n                const updateDialogText = (text) => {\r\n                    store.dispatch(updateDialogActionCreator(text));\r\n                };\r\n                return <Dialogs\r\n                    addNewDialog={addDialog}\r\n                    updDialog={updateDialogText}\r\n                    dialogsName={state.messagesPage.dialogsData}\r\n                    dialogsList={state.messagesPage.messagesData}\r\n                    newDialogsText={state.messagesPage.newDialogText}/>\r\n            }\r\n        }\r\n        </StoreContext.Consumer>\r\n    );\r\n};*/"],"sourceRoot":""}